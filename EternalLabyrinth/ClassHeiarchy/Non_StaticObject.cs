using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using System.Collections.Generic;
using System;

namespace EternalLabyrinth

    //DO NOT EDIT : Zaaim
{
    public class Non_StaticObject : Object
    {
        public Dictionary<string, Animation> animations; //Dictionary of animations, e.g ["WALK", Animation]
        public string currentAnimation; //Holds the key used to call the current animation from the Dictionay<string, Animation> animations
        public string defaultAnimation; //Holds the key for the animation which the object should fall back to
        public Rectangle currentFrame; //Holds the source rectangle which is updates/generated by the Animation class
        public Texture2D flipText; //TESTING COLLISIONS, currently doesnt work
        public Vector2 position;

        public Non_StaticObject(Texture2D t, Rectangle r, Color c, bool iFR) : base(t, r, c)
        {
            animations = new Dictionary<string, Animation>();
            isFacingRight = iFR;
            timeStamps = new Dictionary<string, int>();
            LoadAnimations(); //Calls abstract method LoadAnimations which allows every subcless to load their own animations
            position = new Vector2(hitBox.X, hitBox.Y);
        }

        public Non_StaticObject() : base()
        {
            animations = new Dictionary<string, Animation>();
            isFacingRight = true;

            LoadAnimations();
        }

        public virtual void LoadAnimations() { }


        //Call (CALL IN THE SUBCLASSES UPDATE METHOD) to play an animation of enitity from the Dictionary 
        public void PlayAnimation(string key)
        {
            //Checks if animation is allowed to change
            if(animations[currentAnimation].isRestricting)
            {
                return;
            }
            //Plays new animation
            animations[currentAnimation].Reset();
            currentAnimation = key;
            animations[key].Play();
        }

        //Plays animation by calculation it with gameTime
        public override void Update()
        {
            position.X = hitBox.X;
            position.Y = hitBox.Y;
            //If the current animation ever ends fall back to default aniamtion (mimmicing a delegate)
            currentFrame = animations[currentAnimation].getCurrentFrame();
            if (!animations[currentAnimation].isLoop && animations[currentAnimation].isDone && !animations[currentAnimation].paused)
            {
                animations[currentAnimation].Reset();
                currentAnimation = defaultAnimation;
            }

        }

        //Call (CALL IN THE SUBCLASSES UPDATE METHOD) to set the direction of enitiy
        public void setFacingRight(bool isRight)
        {
            if(isRight)
            {
                isFacingRight = true;
            }
            else
            {
                isFacingRight = false;
            }
        }

        public virtual void updateAnimationTimeStamps() { }

        public override void Draw(SpriteBatch spriteBatch)
        {
            if (isFacingRight)
            {
                spriteBatch.Draw(text, rect, currentFrame, col, 0, new Vector2(0), SpriteEffects.None, 0f);
            }
            else
            {
                spriteBatch.Draw(text, rect, currentFrame, col, 0, new Vector2(0), SpriteEffects.FlipHorizontally, 0f);
            }
            //spriteBatch.Draw(Game1.white, hitBox, Color.Green * .3f);
        }

        //Used in Collisions
        public Color[] getColorData()
        {
            Color[] data = new Color[currentFrame.Width * currentFrame.Height];
            this.text.GetData(0, currentFrame, data, 0, data.Length);

            if (this is SkeltriStomp)
            {
                if (!isFacingRight)
                {
                    Color[] temp = new Color[data.Length];

                    for (int r = 0; r < currentFrame.Height; r++)
                    {
                        for (int c = 0; c < currentFrame.Width; c++)
                        {
                            temp[r * (currentFrame.Width - 1) + (currentFrame.Width - 1) - c] = data[r * (currentFrame.Width - 1) + c];
                        }
                    }

                    data = temp;
                }
            }

            //if (this is Player)
            //{
            //    if (!isFacingRight)
            //    {
            //        Color[] temp = new Color[data.Length];

            //        for (int r = 0; r < currentFrame.Height; r++)
            //        {
            //            for (int c = 0; c < currentFrame.Width; c++)
            //            {
            //                temp[r * (currentFrame.Width - 1) + (currentFrame.Width - 1) - c] = data[r * (currentFrame.Width - 1) + c];
            //            }
            //        }

            //        data = temp;
            //    }
            //}

            return data;
         }

        //Used for Collision testing
        public Rectangle getFrame()
        {
            return currentFrame;
        }
    }
}
